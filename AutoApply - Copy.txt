# -*- coding: utf-8 -*-

import csv
import os
import time
import json
import re
from selenium import webdriver
from selenium.webdriver.edge.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from selenium.common.exceptions import (
    NoSuchElementException, TimeoutException, ElementNotInteractableException,
    StaleElementReferenceException, MoveTargetOutOfBoundsException
)
from selenium.webdriver.support.ui import Select # Needed for standard dropdowns

# --- Configuration ---
SCRAPER_OUTPUT_FOLDER = r"C:\Users\yunus\source\repos\job_scraper\LinkedIn_Job_Scrapes" # CHANGE IF NEEDED
CSV_FILENAME_PATTERN = "filtered_LinkedInJobs_Run{}.csv" # Pattern to find the CSV
APPLY_MARKER_COLUMN = "Apply Status" # Column header you added manually
APPLY_MARKER_VALUE = "Apply"        # Value indicating you want to apply
ANSWERS_DB_FILE = "application_answers.json"
WAIT_TIMEOUT = 5 # Seconds to wait for elements

# --- Helper Functions ---

def find_latest_csv(folder_path, pattern):
    """Finds the CSV file with the highest run number."""
    latest_run = 0
    latest_file = None
    try:
        for filename in os.listdir(folder_path):
            base_name = pattern.split('{}')[0]
            if filename.startswith(base_name) and filename.endswith(".csv"):
                try:
                    # Extract run number using regex for safety
                    match = re.search(r'Run(\d+)\.csv$', filename)
                    if match:
                        run_num = int(match.group(1))
                        if run_num > latest_run:
                            latest_run = run_num
                            latest_file = os.path.join(folder_path, filename)
                except (ValueError, IndexError):
                    continue # Ignore files not matching the pattern exactly
    except FileNotFoundError:
        print(f"ERROR: Output folder not found: {folder_path}")
        return None

    if latest_file:
        print(f"Found latest CSV: {latest_file}")
    else:
        print(f"ERROR: No CSV files matching pattern '{pattern}' found in {folder_path}")
    return latest_file

def load_answers(filepath):
    """Loads the Q&A database from JSON."""
    if os.path.exists(filepath):
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                return json.load(f)
        except json.JSONDecodeError:
            print(f"Warning: Could not decode JSON from {filepath}. Starting with empty answers.")
            return {}
        except Exception as e:
            print(f"Error loading answers from {filepath}: {e}")
            return {}
    return {}

def save_answers(filepath, answers_db):
    """Saves the Q&A database to JSON."""
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(answers_db, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"Error saving answers to {filepath}: {e}")

def normalize_question(text):
    """Cleans question text for better matching."""
    if not text:
        return ""
    # Lowercase, strip whitespace, remove common punctuation that might vary
    text = text.lower().strip()
    text = re.sub(r'[.:*?]+$', '', text) # Remove trailing punctuation often found in labels
    text = re.sub(r'\s+', ' ', text) # Normalize whitespace
    return text.strip()

def get_associated_label(driver, element):
    """Tries to find the <label> associated with a form element."""
    try:
        # 1. Try finding label by 'for' attribute matching element's ID
        element_id = element.get_attribute('id')
        if element_id:
            # Need to escape quotes if ID contains them, although rare
            escaped_id = element_id.replace('"', '\\"')
            try:
                label = driver.find_element(By.CSS_SELECTOR, f'label[for="{escaped_id}"]')
                return label.text
            except NoSuchElementException:
                pass # Fall through to other methods

        # 2. Try finding label by traversing upwards to a common parent (e.g., div, p)
        #    and looking for a label sibling or child label. This is highly structure-dependent.
        #    Example: Check parent, then grandparent for a <label> tag
        parent = element.find_element(By.XPATH, '..')
        try:
            label = parent.find_element(By.TAG_NAME, 'label')
            return label.text
        except NoSuchElementException:
            # Try grandparent
            grandparent = parent.find_element(By.XPATH, '..')
            try:
                label = grandparent.find_element(By.TAG_NAME, 'label')
                return label.text
            except NoSuchElementException:
                pass # Fall through

        # 3. Try finding preceding sibling label (less reliable)
        try:
            label = element.find_element(By.XPATH, 'preceding-sibling::label')
            return label.text
        except NoSuchElementException:
             pass

        # 4. As a last resort, maybe placeholder text or aria-label?
        placeholder = element.get_attribute('placeholder')
        if placeholder:
             return placeholder # Often a good hint

        aria_label = element.get_attribute('aria-label')
        if aria_label:
            return aria_label

    except StaleElementReferenceException:
        print("Warning: Stale element reference while trying to find label.")
        return None
    except Exception as e:
        print(f"Warning: Error finding label: {e}") # Log other potential errors
        return None
    return None # No label found

def attempt_fill_field(element, answer):
    """Attempts to fill a form field with the given answer. More robust needed."""
    try:
        tag_name = element.tag_name.lower()
        element_type = element.get_attribute('type')

        # Clear field first if it's a text input or textarea
        if tag_name in ['input', 'textarea'] and element_type not in ['checkbox', 'radio', 'submit', 'button', 'file']:
             try:
                 element.clear()
                 time.sleep(0.2) # Small pause after clear
             except ElementNotInteractableException:
                 print("Warning: Field not interactable for clearing.")
                 # Sometimes clearing isn't needed or possible, proceed anyway

        if tag_name == 'input' or tag_name == 'textarea':
            # Handle text, email, phone, etc.
            if element_type not in ['checkbox', 'radio', 'submit', 'button', 'file']:
                 element.send_keys(answer)
                 print(f"   Attempted to fill field with: '{answer[:30]}...'") # Log truncated answer
                 return True
            # TODO: Add handling for radio/checkbox if needed (more complex - requires matching values)
        elif tag_name == 'select':
            # Basic dropdown handling - might need exact text match or value match
            from selenium.webdriver.support.ui import Select
            try:
                select = Select(element)
                select.select_by_visible_text(answer)
                print(f"   Attempted to select dropdown option: '{answer}'")
                return True
            except NoSuchElementException:
                print(f"   Warning: Option '{answer}' not found in dropdown.")
                # Try selecting by value as a fallback?
                try:
                    select.select_by_value(answer)
                    print(f"   Attempted to select dropdown by value: '{answer}'")
                    return True
                except NoSuchElementException:
                    print(f"   Warning: Value '{answer}' also not found in dropdown.")
            except Exception as e_select:
                print(f"   Error selecting dropdown option: {e_select}")
        # Add more element types as needed (checkboxes, radio buttons require specific logic)

    except ElementNotInteractableException:
        print("   Warning: Element not interactable. Could not fill.")
    except StaleElementReferenceException:
        print("   Warning: Stale element reference during filling.")
    except Exception as e:
        print(f"   Error attempting to fill field: {e}")
    return False

# --- (Helper function for Action Click - Optional but cleaner) ---
def attempt_action_click(driver, element):
    """Tries to click an element using ActionChains."""
    try:
        print(f"    Attempting ActionChains click on: {element.tag_name} {element.get_attribute('outerHTML')[:60]}...")
        actions = ActionChains(driver)
        actions.move_to_element(element).click().perform()
        print("    ActionChains click performed.")
        time.sleep(0.3) # Small pause after click
        return True
    except (ElementNotInteractableException, MoveTargetOutOfBoundsException) as action_err:
         print(f"    ActionChains click failed ({type(action_err).__name__}).")
    except Exception as action_other_err:
         print(f"    ActionChains click failed (Other Error: {action_other_err}).")
    return False

# --- Main Script ---
if __name__ == "__main__":
    # Use the 'filtered' pattern if that's your input now
    latest_csv = find_latest_csv(SCRAPER_OUTPUT_FOLDER, "filtered_LinkedInJobs_Run{}.csv") # Adjusted pattern
    if not latest_csv:
        exit()

    answers_db = load_answers(ANSWERS_DB_FILE)
    jobs_to_apply = []

    # 1. Read the CSV and find marked jobs
    try:
        with open(latest_csv, 'r', newline='', encoding='utf-8-sig') as csvfile: # Use utf-8-sig to handle potential BOM
            reader = csv.DictReader(csvfile)
            if APPLY_MARKER_COLUMN not in reader.fieldnames:
                print(f"ERROR: Column '{APPLY_MARKER_COLUMN}' not found in {latest_csv}.")
                print(f"Please add this column and mark jobs with '{APPLY_MARKER_VALUE}' before running.")
                exit()

            for i, row in enumerate(reader):
                apply_status = row.get(APPLY_MARKER_COLUMN, '').strip()
                if apply_status.lower() == APPLY_MARKER_VALUE.lower():
                    job_info = {
                        'row_num': i + 2, # +1 for header, +1 for 0-index
                        'title': row.get('Job Title', 'N/A'),
                        'company': row.get('Company', 'N/A'),
                        'link': row.get('Link', 'N/A'),
                    }
                    if job_info['link'] != 'N/A' and job_info['link']: # Ensure link is not empty
                        jobs_to_apply.append(job_info)
                    else:
                        print(f"Skipping Row {job_info['row_num']} ({job_info['title']}): Missing or Invalid Link")

    except FileNotFoundError:
        print(f"ERROR: CSV file not found: {latest_csv}")
        exit()
    except Exception as e:
        print(f"Error reading CSV file {latest_csv}: {e}")
        exit()

    if not jobs_to_apply:
        print(f"No jobs found marked with '{APPLY_MARKER_VALUE}' in column '{APPLY_MARKER_COLUMN}' in {latest_csv}.")
        exit()

    print(f"\nFound {len(jobs_to_apply)} jobs marked for application help.")

    # 2. Process each marked job
    driver = None # Initialize driver outside the loop
    for job_index, job in enumerate(jobs_to_apply):
        print(f"\n--- Processing Job {job_index + 1}/{len(jobs_to_apply)} (Row {job['row_num']}): {job['title']} at {job['company']} ---")
        print(f"Link: {job['link']}")

        try:
            options = Options()
            options.use_chromium = True
            options.add_argument("--no-sandbox")
            options.add_argument("--disable-dev-shm-usage")
            options.add_argument("--start-maximized") # Use maximized window
            options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
            options.add_experimental_option('excludeSwitches', ['enable-logging'])
            # options.add_argument("--headless=new") # Cannot use headless with manual interaction

            driver = webdriver.Edge(options=options)
            wait = WebDriverWait(driver, WAIT_TIMEOUT) # Main wait defined earlier (e.g., 15-20s)

            # --- 1. Navigate to LinkedIn Page ---
            print(f"Navigating to: {job['link']}")
            driver.get(job['link'])
            time.sleep(2) # Initial pause for load

            # --- 2. HANDLE LOGIN MODAL - SINGLE ACTIONCHAINS ATTEMPT ---
            print("Checking for 'Sign in' modal container...")
            try:
                WebDriverWait(driver, 10).until( # Wait up to 10 seconds for the modal container
                    EC.presence_of_element_located((By.CSS_SELECTOR, 'section[aria-modal="true"]'))
                )
                print("Modal container detected. Attempting to dismiss...")
                dismiss_button_selector = 'button.contextual-sign-in-modal__modal-dismiss[aria-label="Dismiss"]'
                try:
                    modal_dismiss_button = WebDriverWait(driver, 10).until( # Find button within 10s
                        EC.presence_of_element_located((By.CSS_SELECTOR, dismiss_button_selector))
                    )
                    print("  Dismiss button found.")
                    # Scroll into view
                    try:
                        driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", modal_dismiss_button)
                        time.sleep(0.3)
                    except Exception as scroll_err: print(f"  Warning: Could not scroll dismiss button into view: {scroll_err}")
                    # Use ActionChains Click
                    print("  Attempting ActionChains click...")
                    if attempt_action_click(driver, modal_dismiss_button): # Use helper
                        print("  Dismiss click successful. Pausing briefly...")
                        time.sleep(2.0) # Pause AFTER successful click
                    else:
                        print("  ActionChains click failed on dismiss button. Proceeding anyway.")
                except TimeoutException: print("  Warning: Modal container found, but dismiss button was not found within timeout.")
                except Exception as e_dismiss: print(f"  An error occurred trying to find or click dismiss button: {e_dismiss}")
            except TimeoutException: print("Modal container not detected. Proceeding...") # Normal if no modal
            except Exception as e_modal_outer: print(f"Error during modal container detection: {e_modal_outer}")

            # --- 3. Find and click the FIRST Apply button on LinkedIn ---
            print("\nSearching for the FIRST job 'Apply' button/link...")
            first_apply_button = None
            first_apply_clicked = False
            possible_first_apply_selectors = [ # Selectors from successful run
                'button.top-card-layout__cta--primary.btn-primary', # This worked previously
                'button[data-tracking-control-name="public_jobs_apply-link-offsite_sign-up-modal"]',
                "//button[normalize-space(.)='Apply' and not(@aria-label='Dismiss')]",
                'button[data-modal="sign-up-modal-outlet"]',
                "//button[contains(normalize-space(.), 'Apply') and not(@aria-label='Dismiss')]"
            ]
            for selector in possible_first_apply_selectors:
                try:
                    print(f"Trying selector for FIRST Apply button: {selector}")
                    wait_short = WebDriverWait(driver, 7) # Shorter wait for trying each selector
                    if selector.startswith('/'): # XPath
                         first_apply_button = wait_short.until(EC.element_to_be_clickable((By.XPATH, selector)))
                    else: # CSS Selector
                        first_apply_button = wait_short.until(EC.element_to_be_clickable((By.CSS_SELECTOR, selector)))
                    if first_apply_button:
                         print("Found FIRST Apply button/link.")
                         driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", first_apply_button)
                         time.sleep(0.5)
                         first_apply_button.click() # Standard click worked here before
                         print("Clicked FIRST Apply button/link.")
                         first_apply_clicked = True
                         break
                except TimeoutException: print(f"Selector '{selector}' timed out or button not clickable.")
                except Exception as e_click: print(f"Error finding/clicking FIRST Apply button with selector '{selector}': {e_click}")

            if not first_apply_clicked:
                print("ERROR: Could not find or click the FIRST Apply button. Skipping job.")
                raise Exception("Failed to initiate application process.") # Raise exception to trigger finally block

            # --- 3b. CHECK FOR SECONDARY MODAL & NAVIGATE VIA HREF ---
            print("\nChecking for secondary sign-up modal...")
            company_website_link_selector_specific = 'a[data-tracking-control-name="public_jobs_apply-link-offsite_sign-up-modal-sign-up-later"]'
            secondary_modal_container_selector = 'div.sign-up-modal__direct-apply-on-company-site'
            navigated_to_company_site = False
            try:
                WebDriverWait(driver, 5).until( # Short wait for this modal
                    EC.presence_of_element_located((By.CSS_SELECTOR, secondary_modal_container_selector))
                )
                print("Secondary sign-up modal detected. Looking for 'company website' link element...")
                try:
                    company_website_link_element = WebDriverWait(driver, 10).until(
                         EC.presence_of_element_located((By.CSS_SELECTOR, company_website_link_selector_specific))
                    )
                    print("Found 'company website' link element.")
                    try:
                        company_href = company_website_link_element.get_attribute('href')
                        if company_href:
                            print(f"  Extracted href: {company_href}")
                            print("  Navigating directly via driver.get()...")
                            driver.get(company_href)
                            navigated_to_company_site = True
                            print("  Navigation successful. Pausing...")
                            time.sleep(3.0) # Pause after navigation
                        else: print("  Warning: Found link element, but href attribute was empty.")
                    except Exception as e_href: print(f"  Error extracting href or navigating: {e_href}")
                except TimeoutException: print("  Warning: Secondary modal detected, but 'company website' link element not found.")
                except Exception as e_link_find: print(f"  An error occurred trying to find 'company website' link element: {e_link_find}")
            except TimeoutException:
                print("Secondary sign-up modal not detected. Assuming direct redirect or different page state.")
                time.sleep(2.0) # Small pause for potential redirect

            # --- 4. Wait for User Interaction on ATS ---
            print("\n>>> ACTION REQUIRED <<<")
            print("The script has navigated to the potential application page.")
            print("1. Please complete any necessary LOGIN or initial steps.")
            print("2. Navigate to the main application form page if needed.")
            try:
                current_url = driver.current_url
                print(f"Current URL: {current_url}")
            except Exception as e_get_url:
                 print(f"Could not get current URL: {e_get_url}")


            while True:
                user_ready = input("3. Type 'scan' and press Enter when you are ready for the script to scan the current page for questions (or type 'skip' to go to next job): ").strip().lower()
                if user_ready == 'scan':
                    break
                elif user_ready == 'skip':
                     print("Skipping application scan for this job.")
                     raise Exception("User skipped application scan.") # Use exception to cleanly exit to finally
                else:
                    print("Please type 'scan' or 'skip'.")

            print("\nScanning page for form fields...")
            time.sleep(1)

            # --- REVISED FORM ELEMENT PROCESSING with ActionChains ---
            processed_group_questions = set() # Track checkbox/radio groups processed on this page
            group_question_map = {} # Maps element ID/name to group question text
            checkbox_radio_elements = []

            # --- Pass 1: Identify Group Questions ---
            try:
                potential_group_parents = driver.find_elements(By.CSS_SELECTOR, 'fieldset, div[role="radiogroup"], div[role="group"]')
                all_inputs = driver.find_elements(By.TAG_NAME, 'input')
                print(f"Scanning {len(potential_group_parents)} potential group containers and {len(all_inputs)} inputs for groups...")
                # ... (Full Pass 1 logic as provided in previous answer) ...
                for element in all_inputs:
                    try:
                         tag_name = element.tag_name.lower()
                         elem_type = element.get_attribute('type').lower() if tag_name == 'input' else None
                         if tag_name == 'input' and elem_type in ['checkbox', 'radio']:
                            checkbox_radio_elements.append(element)
                            group_question = None
                            input_description = element.get_attribute('description')
                            input_name = element.get_attribute('name')
                            if input_description: group_question = input_description
                            else:
                                try:
                                    fieldset = element.find_element(By.XPATH, './ancestor::fieldset[legend]')
                                    legend = fieldset.find_element(By.TAG_NAME, 'legend')
                                    if legend.text: group_question = legend.text.strip()
                                except NoSuchElementException:
                                    aria_label = element.get_attribute('aria-labelledby')
                                    if aria_label:
                                        try:
                                            label_element = driver.find_element(By.ID, aria_label)
                                            group_question = label_element.text.strip()
                                        except NoSuchElementException: pass
                                    if not group_question:
                                        try:
                                            group_div = element.find_element(By.XPATH, './ancestor::div[@role="group" or @role="radiogroup"][@aria-labelledby]')
                                            aria_label_id = group_div.get_attribute('aria-labelledby')
                                            label_element = driver.find_element(By.ID, aria_label_id)
                                            group_question = label_element.text.strip()
                                        except NoSuchElementException: pass
                            if group_question and input_name:
                                normalized_group_q = normalize_question(group_question)
                                if input_name not in group_question_map:
                                     group_question_map[input_name] = normalized_group_q
                                     print(f"  Identified Group: '{normalized_group_q}' (Input Name: {input_name})")
                    except StaleElementReferenceException: print("  Stale element during group identification."); break
                    except Exception as e_group_id: print(f"  Error identifying group for an element: {e_group_id}")
            except Exception as e_pass1: print(f"Error during Pass 1 (Group Identification): {e_pass1}")

            # --- Pass 2: Process Elements Intelligently ---
            processed_elements_html = set()
            try:
                form_elements = driver.find_elements(By.CSS_SELECTOR, 'input, textarea, select')
                print(f"\nStarting Pass 2: Processing {len(form_elements)} input/textarea/select elements.")
            except Exception as e_refetch: print(f"Error re-fetching form elements for Pass 2: {e_refetch}"); form_elements = []

            for element in form_elements:
                try:
                    element_outer_html = element.get_attribute('outerHTML')
                    if not element.is_displayed() or element_outer_html in processed_elements_html: continue
                    processed_elements_html.add(element_outer_html)

                    tag_name = element.tag_name.lower()
                    elem_type = element.get_attribute('type').lower() if tag_name == 'input' else None
                    question_text = None
                    try:
                        label_element = driver.find_element(By.XPATH, f".//label[@for='{element.get_attribute('id')}']")
                        if label_element.text: question_text = label_element.text.strip()
                    except NoSuchElementException: pass
                    if not question_text:
                        q_desc = element.get_attribute('description'); q_placeholder = element.get_attribute('placeholder'); q_aria_label = element.get_attribute('aria-label')
                        question_text = q_desc or q_aria_label or q_placeholder or element.get_attribute('name') or f"Unknown Field (type: {elem_type or tag_name})"
                    normalized_q = normalize_question(question_text or "")

                    print(f"\nProcessing Field: '{question_text}' (Type: {elem_type or tag_name})")
                    try:
                        driver.execute_script("arguments[0].scrollIntoView({block: 'center', inline: 'nearest'});", element); time.sleep(0.3)
                    except Exception as scroll_err: print(f"  Warning: Could not scroll element into view: {scroll_err}")

                    # --- Handle Checkbox/Radio Groups with ActionChains ---
                    if elem_type in ['checkbox', 'radio']:
                        # ... (Full checkbox/radio logic using group_question_map and attempt_action_click as provided in previous answer) ...
                        input_name = element.get_attribute('name')
                        group_question = group_question_map.get(input_name)
                        if group_question:
                            if group_question not in processed_group_questions:
                                processed_group_questions.add(group_question)
                                print(f"  Handling Group: '{group_question}'")
                                if group_question in answers_db:
                                    selected_option_text = answers_db[group_question]
                                    print(f"  Stored Answer (Option Text): '{selected_option_text}'")
                                    found_and_clicked = False
                                    try:
                                        group_elements = driver.find_elements(By.CSS_SELECTOR, f'input[name="{input_name}"]')
                                        for option_element in group_elements:
                                             option_label_text = get_associated_label(driver, option_element)
                                             if option_label_text and normalize_question(option_label_text) == normalize_question(selected_option_text):
                                                 if not option_element.is_selected():
                                                     print(f"    Clicking option: '{option_label_text}' using ActionChains")
                                                     if attempt_action_click(driver, option_element): found_and_clicked = True
                                                     else: print("      ActionChains click failed. Manual check needed.")
                                                 else: print(f"    Option '{option_label_text}' already selected."); found_and_clicked = True
                                                 break
                                    except Exception as e_find_click: print(f"    Error finding/clicking stored checkbox option: {e_find_click}")
                                    if not found_and_clicked: print(f"  Warning: Could not find or click stored option '{selected_option_text}'. Manual selection needed.")
                                else: # Ask user
                                    print(f"  ? Group question '{group_question}' not found in DB.")
                                    # ... (List options logic) ...
                                    try:
                                        group_elements = driver.find_elements(By.CSS_SELECTOR, f'input[name="{input_name}"]'); print("    Available options:")
                                        for opt_el in group_elements: print(f"      - {get_associated_label(driver, opt_el) or 'Unknown'}")
                                    except Exception as e_list_opt: print(f"    Error listing options: {e_list_opt}")
                                    user_answer = input(f"  Enter the EXACT text of the option to select for '{group_question}': ").strip()
                                    clicked = False
                                    if user_answer:
                                        try:
                                            group_elements = driver.find_elements(By.CSS_SELECTOR, f'input[name="{input_name}"]')
                                            for opt_el in group_elements:
                                                 opt_label = get_associated_label(driver, opt_el)
                                                 if opt_label and opt_label.strip() == user_answer:
                                                     print(f"    Clicking user option: '{opt_label}' using ActionChains")
                                                     if attempt_action_click(driver, opt_el):
                                                         answers_db[group_question] = user_answer; save_answers(ANSWERS_DB_FILE, answers_db)
                                                         print(f"    Saved answer for group '{group_question}'."); clicked = True
                                                     else: print("      ActionChains click failed. Manual selection needed.")
                                                     break
                                        except Exception as e_user_find_click: print(f"    Error finding/clicking user checkbox option: {e_user_find_click}")
                                    if not clicked and user_answer: print("    Warning: Could not find or click the specified option.")
                        elif not group_question and elem_type in ['checkbox', 'radio']: print("  Warning: Checkbox/Radio found, but couldn't identify group. Skipping.")

                    # --- Handle File Inputs ---
                    elif elem_type == 'file':
                        # ... (Full file input logic using os.path.exists and send_keys as provided previously) ...
                        print("  Handling File Input.")
                        if normalized_q in answers_db:
                             file_path = answers_db[normalized_q]
                             print(f"  Stored file path: '{file_path}'")
                             if os.path.exists(file_path):
                                 try: element.send_keys(file_path); print("    Attempted to set file path.")
                                 except Exception as e_send_keys: print(f"    Error using send_keys for file: {e_send_keys}. Manual upload likely required.")
                             else: print(f"  Warning: Stored file path '{file_path}' does not exist!"); del answers_db[normalized_q]
                        if normalized_q not in answers_db:
                             print(f"  ? File path for '{question_text}' not found in DB.")
                             while True:
                                 user_path = input(f"  Enter the FULL file path for '{question_text}' (or 'skip'): ").strip().strip('"').strip("'")
                                 if user_path.lower() == 'skip': print("    Skipping file upload."); break
                                 if os.path.exists(user_path):
                                     answers_db[normalized_q] = user_path; save_answers(ANSWERS_DB_FILE, answers_db); print(f"    Saved path '{user_path}'.")
                                     try: element.send_keys(user_path); print("    Attempted to set file path.")
                                     except Exception as e_send_keys_new: print(f"    Error using send_keys for file: {e_send_keys_new}. Manual upload likely required.")
                                     break
                                 else: print("  ERROR: File not found at that path. Please check and try again, or type 'skip'.")

                    # --- Handle Standard Select Dropdowns ---
                    elif tag_name == 'select':
                        # ... (Full standard select logic using attempt_fill_field and listing options as provided previously) ...
                        print("  Handling Standard Select Dropdown.")
                        if normalized_q in answers_db:
                            answer = answers_db[normalized_q]; print(f"  Stored Answer (Option Text): '{answer}'")
                            if not attempt_fill_field(element, answer): print("  -> Manual selection might be required.")
                        else:
                            print(f"  ? Dropdown option for '{question_text}' not found in DB.")
                            options = []
                            try:
                                 select_obj = Select(element); options = [opt.text for opt in select_obj.options if opt.text and not opt.is_disabled()]
                                 if options: print("    Available options:"); [print(f"      - {opt_text}") for opt_text in options]
                                 else: print("    No selectable options found.")
                            except Exception as e_list_select: print(f"    Error listing select options: {e_list_select}")
                            user_answer = input(f"  Enter the EXACT text of the option to select for '{question_text}': ").strip()
                            if user_answer:
                                 if options and user_answer not in options: print(f"  Warning: '{user_answer}' not listed. Attempting anyway...")
                                 if attempt_fill_field(element, user_answer):
                                     answers_db[normalized_q] = user_answer; save_answers(ANSWERS_DB_FILE, answers_db); print(f"    Saved answer '{user_answer}'.")
                                 else: print("  Warning: Could not select the specified option.")

                    # --- Handle Custom Dropdowns with ActionChains + Arrow Keys ---
                    elif (tag_name == 'input' and element.get_attribute('role') == 'combobox') or \
                         (tag_name == 'div' and 'select' in element.get_attribute('class') and element.find_elements(By.TAG_NAME, 'button')) or \
                         (normalized_q == normalize_question("EXPORT COMPLIANCE")): # Use normalized question for matching heuristic
                         print("  Handling Potential Custom Dropdown (Attempting Keyboard Navigation).")
                         automation_failed = False

                         # Use normalized question text as the key
                         if normalized_q in answers_db:
                             stored_answer = answers_db[normalized_q]
                             print(f"  Stored Answer: '{stored_answer}'. Attempting automatic selection via keyboard.")

                             # 1. Try to open the dropdown (Click the main element/button)
                             print("    Trying to open dropdown...")
                             dropdown_opener = element
                             try:
                                 button_inside = element.find_element(By.TAG_NAME, 'button') # Check for inner button
                                 if button_inside.is_displayed(): dropdown_opener = button_inside
                             except NoSuchElementException: pass

                             if not attempt_action_click(driver, dropdown_opener):
                                 print("    Failed to open dropdown with ActionChains. Manual selection required.")
                                 automation_failed = True
                             else:
                                 # 2. Find options and simulate key presses
                                 try:
                                     # Wait briefly for options to potentially render after open click
                                     time.sleep(0.75) # Adjust if needed

                                     # Find *potential* options to determine index
                                     # Selector needs to target the individual option elements (li, div, etc.)
                                     # ADJUST SELECTOR BASED ON ACTUAL DROPDOWN STRUCTURE
                                     options_selector = "div[id*='react-select'][role='option'], div[class*='option']"
                                     print(f"    Looking for potential options using: {options_selector}")
                                     # Wait for at least one option to be present
                                     WebDriverWait(driver, 5).until(
                                         EC.presence_of_element_located((By.CSS_SELECTOR, options_selector))
                                     )
                                     # Get all currently visible/present options
                                     option_elements = driver.find_elements(By.CSS_SELECTOR, options_selector)
                                     print(f"    Found {len(option_elements)} potential option elements.")

                                     found_index = -1
                                     for index, opt_element in enumerate(option_elements):
                                         # Need to get the text robustly - may be nested
                                         option_text = opt_element.text.strip()
                                         print(f"      Checking option {index}: '{option_text}'")
                                         # Compare with stored answer (handle potential non-breaking spaces)
                                         if normalize_question(option_text.replace(' ',' ')) == normalize_question(stored_answer):
                                             found_index = index
                                             print(f"      Match found at index {found_index}!")
                                             break

                                     if found_index != -1:
                                         # 3. Send ARROW_DOWN keys and ENTER
                                         print(f"    Sending {found_index} ARROW_DOWN keys...")
                                         actions = ActionChains(driver)
                                         for _ in range(found_index):
                                             actions.send_keys(Keys.ARROW_DOWN)
                                             actions.pause(0.1) # Small pause between keys
                                         actions.send_keys(Keys.ENTER)
                                         actions.perform()
                                         print(f"    Successfully selected '{stored_answer}' via keyboard.")
                                         time.sleep(0.5) # Pause after selection
                                     else:
                                         print(f"    Error: Could not find index for stored answer '{stored_answer}' among visible options.")
                                         automation_failed = True

                                 except TimeoutException:
                                     print("    Error: Potential options did not appear after opening dropdown. Manual selection required.")
                                     automation_failed = True
                                 except Exception as e_keys_select:
                                      print(f"    Error during keyboard selection: {e_keys_select}. Manual selection required.")
                                      automation_failed = True

                             # If automation failed, prompt user
                             if automation_failed:
                                 print(f"  >>> Automation failed. Please manually ensure '{stored_answer}' is selected for '{question_text}'. <<<")
                                 input("      Press Enter here AFTER confirming/selecting manually...")

                         else: # Answer not in DB
                             print(f"  ? Custom dropdown option for '{question_text}' not found in DB.")
                             # Try to open dropdown first
                             print("    Trying to open dropdown for manual selection...")
                             dropdown_opener = element
                             try: button_inside = element.find_element(By.TAG_NAME, 'button'); dropdown_opener = button_inside if button_inside.is_displayed() else element
                             except NoSuchElementException: pass
                             attempt_action_click(driver, dropdown_opener) # Best effort

                             print(f"  >>> Please manually select the desired option for '{question_text}' in the browser NOW. <<<")
                             input("      Press Enter here AFTER you have selected the option...")
                             user_answer = input(f"      Type the EXACT text of the option you just selected: ").strip()
                             if user_answer:
                                 answers_db[normalized_q] = user_answer
                                 save_answers(ANSWERS_DB_FILE, answers_db)
                                 print(f"    Saved answer '{user_answer}' for '{normalized_q}'.")

                    # --- Handle Standard Text Inputs/Textareas ---
                    elif (tag_name == 'input' and elem_type not in ['checkbox', 'radio', 'file', 'submit', 'button', 'reset', 'image', 'hidden']) or \
                         tag_name == 'textarea':
                        # ... (Full standard input logic using attempt_fill_field as provided previously) ...
                         print("  Handling Standard Input/Textarea.")
                         if normalized_q in answers_db:
                             answer = answers_db[normalized_q]; print(f"  Answer found in DB: '{str(answer)[:50]}...'")
                             if not attempt_fill_field(element, answer): print("  -> Manual input might be required.")
                         else:
                             print(f"  ? Answer for '{question_text}' not found in DB.")
                             user_answer = input(f"  Enter answer for '{question_text}': ")
                             answers_db[normalized_q] = user_answer; save_answers(ANSWERS_DB_FILE, answers_db); print(f"  Saved answer for '{normalized_q}'.")
                             attempt_fill_field(element, user_answer)

                    # --- Skip other element types ---
                    else:
                         print(f"  Skipping element (Type: {elem_type or tag_name}, Question: '{question_text}')")


                except StaleElementReferenceException:
                    # Log the error but CONTINUE to the next element
                    print(f"Warning: Stale element reference encountered for an element (likely near '{question_text}'). Skipping this specific element and continuing scan...")
                    # continue instead of break
                    continue # Try the next element in the list
                except NoSuchElementException as e_missing:
                    print(f"Error: Could not find an element during processing for '{question_text}': {e_missing}")
                    continue # Also continue here if an element suddenly disappears
                except Exception as e_element_process:
                    print(f"Error processing element for question '{question_text}': {e_element_process}")
                    # Decide whether to continue or stop based on severity - let's continue for now
                    print("  Attempting to continue to the next element...")
                    continue

            print("\nFinished scanning fields on the current page.")
            print("Please review the form, fill any remaining fields manually, and submit the application.")
            input("Press Enter when you are finished with this application to continue to the next job...")


        except Exception as e_main_job_loop:
            print(f"\n--- An error occurred processing job {job['title']}: {e_main_job_loop} ---")
            if "User skipped application scan" in str(e_main_job_loop):
                pass # This is an expected "error" to skip
            else:
                 print("Recommend manual review for this job application.")
                 # Optionally add more detailed traceback here if needed
                 # import traceback
                 # print(traceback.format_exc())
                 input("Press Enter to acknowledge and continue to the next job...")


        finally:
            # Ensure the browser for the current job is closed
            if driver:
                try:
                    print("Closing browser window for this job...")
                    driver.quit()
                    driver = None # Reset driver variable
                except Exception as e_quit:
                    print(f"Error trying to quit WebDriver: {e_quit}")
            # Save answers database just in case
            save_answers(ANSWERS_DB_FILE, answers_db)

    print("\n--- All marked jobs processed ---")
    print(f"Final answers database saved to {ANSWERS_DB_FILE}")